burrito
=======

Burrito wraps up all javascript expressions in a trace function before executing
them.

This is super useful if you want to roll your own stack traces or build a code
coverage tool.

examples
========

microwave
---------

examples/microwave.js

````javascript
var burrito = require('burrito');

var res = burrito.microwave('Math.sin(2)', function (node) {
    if (node.name === 'num') node.wrap('Math.PI / %s');
});

console.log(res); // sin(pi / 2) == 1
````

output:

    1

wrap
----

examples/wrap.js

````javascript
var burrito = require('burrito');

var src = burrito('f() && g(h())\nfoo()', function (node) {
    if (node.name === 'call') node.wrap('qqq(%s)');
});

console.log(src);
````

output:

    qqq(f()) && qqq(g(qqq(h())));

    qqq(foo());

methods
=======

    var burrito = require('burrito');

burrito(code, cb)
-----------------

Given some source `code` and a function `trace`, walk the ast by expression.

The `cb` gets called with a node object described below.

burrito.microwave(code, context={}, cb)
---------------------------------------

Like `burrito()` except the result is run using
`vm.runInNewContext(res, context)`.

node object
===========

node.name
---------

Name is a string that contains the type of the expression as named by uglify.

node.wrap(s)
------------

Wrap the current expression in `s`.

If `s` is a string, `"%s"` will be replaced with the stringified current
expression.

If `s` is a function, it is called with the stringified current expression and
should return a new stringified expression.

If the `node.name === "binary"`, you get the subterms "%a" and "%b" to play with
too. These subterms are applied if `s` is a function too: `s(expr, a, b)`.

node.node
---------

The raw ast data generated by uglify.

installation
============

With [npm](http://npmjs.org) you can just:

    npm install burrito

kudos
=====

Heavily inspired by (and previously mostly lifted outright from) isaacs's nifty
tmp/instrument.js thingy from uglify-js.
